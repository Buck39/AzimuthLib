--[[ This file allows to create modular plans from parts. Parts can be loaded from xml files or generated by you.
 Keep in mind
* All part names should be unique
* If you want to use one part several times, don't use table reference, use deep copy
]]
--[====[ Example: {
  onPlanFinished = "onPlanFinishedCallbackInMyNamespace", -- (optional) triggers async generation. function will get resulting plana and data passed as arguments
  onStart = "onStart", -- (optional) execute code before plan construction started
  prefix = "myplansfolder", -- (optional) use if your plans are stored in "data/plans/myplansfolder"
  root = { -- main part of the plan
    conditions = "condition", -- (optional) use it to determine if part should be there
    plan = "eye",
    onLoad = "onLoad", -- (optional) executed after plan was loaded, but not attached yet. Here you can scale, rotate and deform plan
    onFinished = "onFinished", -- (optional) will be executed after plan and it's children were loaded and assembled
    children = {
      carapace = {
        conditions = "condition", -- (optional) use it to determine if part should be there
        plan = {"carapace", "carapace_damaged1", "carapace_damaged2"}, -- you can also select random plan from an array
        scale = vec3(1, 2, 2),
        displace = vec3(0, 1, 1),
        rotate = {vec3(0, 1, 0), 0},
        mirror = {vec3(0, 1, 0), vec3(40, 20, 11)},
        material = Material(3),
        color = ColorRGB(1, 0.5, 1),
        onLoad = "onLoad", -- (optional) executed after plan was loaded, but not attached yet. Here you can scale, rotate and deform plan
        parentBlock = 1, -- parent plan block to connect with child plan
        childBlock = 0, -- child plan block to connect with parent plan
        offset = vec3(2, 0, 0), -- blocks will be placed inside one another. here you can specify offset
        onFinished = "onFinished", -- (optional) will be executed after plan and it's children were loaded and assembled
        children = {
          leftArm = {
            plan = {
              leftArm = 0.6, -- parts can also have weights
              leftArm_damaged = 0.3,
              leftArm_broken = 0.15
            },
            parentBlock = 24,
            childBlock = 3,
            offset = vec3(-4, 0, 0)
          },
          rightArm = {
            incompatible = {"leftArm"}, -- (optional) lightweight conditions - don't use this part is plan has specified parts
            plan = "plan", -- you can use function to generate plan, instead of loading it from a file
            parentBlock = "parentBlock1", -- most of variables can be replaced with functions
            childBlock = "childBlock1",
            offset = "offset1"
          }
        }
      }
    }
  },
  scale = 1.5, -- (optional) scale for the whole plan
  material = Material(3), -- (optional) material for the whole plan
  functions = {
    onStart = [[function(data) .. end]], -- execute code before plan construction started,
    condition = [[function(partName, parentName, data) .. return true/false end]], -- use it to determine if part should be there
    onLoad = [[function(partName, planName, plan, parentName, data) .. end]], -- executed after plan was loaded, but not attached yet. Here you can scale, rotate and deform plan
    onFinished = [[function(partName, plan, data) .. end]], --  will be executed after plan and it's children were loaded and assembled
    plan = [[function(partName, parentName, data) .. return planName, plan end]], -- you can use function to generate plan, instead of loading it from a file
    parentBlock = [[function(partName, planName, plan, parentName, parentPlan, data) .. end]],
    childBlock = [[function(partName, planName, plan, parentName, parentPlan, data) .. end]],
    offset = [[function(partName, planName, plan, parentName, parentPlan, data) .. end]] 
  }
}]====]

function ModularPlan(config)
    config.time = appTimeMs()
    config.x, config.y = Sector():getCoordinates()
    
    local functions = ""
    if config.functions then
        functions = {""}
        for k, v in pairs(config.functions) do
            functions[#functions+1] = k.." = " .. v .. ","
        end
        functions = table.concat(functions)
    end

    local code = [[
        package.path = package.path .. ";data/scripts/lib/?.lua"
        include("randomext")
        include("utility")
        local PlanGenerator = include("plangenerator")

        function run(config)
            local functions = { ]]..functions..[[ }
            local data = { config = config, parts = {} }
            local parent, parentName
            local parents = {}
            local parentNames = {}
            local parentLayers = {}
            local layer = { root = config.root }
            if config.onStart then
                functions[config.onStart](data)
            end

            local temp, plan, plans, weights, parentBlock, childBlock, offset
            ::start::
            for k, v in pairs(layer) do
                print("ModularPlan: k = ", k, v.loaded == true, v.finished == true)
                if v.skipped ~= nil and (v.conditions or v.incompatible) then
                    if v.conditions then
                        v.skipped = not functions[v.conditions](k, parentName, data)
                    else
                        for part, _ in pairs(data.parts) do
                            for _, other in ipairs(v.incompatible) do
                                if other == part then
                                    v.skipped = true
                                    break
                                end
                            end
                            if v.skipped then break end
                        end
                        if not v.skipped then
                            v.skipped = false
                        end
                    end
                end
                if not v.loaded and not v.skipped then
                    temp = type(v.plan)
                    if temp == "string" then
                        plan = v.plan
                        temp = nil
                    elseif temp == "function" then
                        plan, temp = functions[v.plan](k, parentName, data)
                    elseif v.plan[1] then
                        plan = v.plan[math.random(#v.plan)]
                    else
                        plans = {}
                        weights = {}
                        for p, weight in pairs(v.plan) do
                            plans[#plans+1] = p
                            weights[#weights+1] = weight
                        end
                        plan = plans[selectByWeight(random(), weights)]
                    end
                    if config.prefix then
                        plan = config.prefix .. "/" .. plan
                    end
                    if temp then
                        data.parts[k] = { name = plan, plan = temp }
                        plan = temp
                    else
                        data.parts[k] = { name = plan }
                        plan = "data/plans/" .. plan .. ".xml"
                        plan = LoadPlanFromFile(plan)
                        if not plan then
                            eprint("[ERROR][AzimuthLib]: Couldn't construct a modular plan, failed to load plan file:", plan)
                            return
                        end
                        data.parts[k].plan = plan
                    end
                    temp = type(v.scale)
                    if temp == "function" then
                        plan:scale(functions[v.scale](k, data.parts[k].name, plan, parentName, data))
                    elseif temp == "number" then
                        plan:scale(vec3(v.scale, v.scale, v.scale))
                    elseif temp ~= "nil" then
                        plan:scale(v.scale)
                    end
                    temp = type(v.displace)
                    if temp == "function" then
                        plan:displace(functions[v.displace](k, data.parts[k].name, plan, parentName, data))
                    elseif temp ~= "nil" then
                        plan:displace(v.displace)
                    end
                    temp = type(v.rotate)
                    if temp == "function" then
                        plan:rotate(functions[v.rotate](k, data.parts[k].name, plan, parentName, data))
                    elseif temp ~= "nil" then
                        plan:rotate(v.rotate[1], v.rotate[2])
                    end
                    temp = type(v.mirror)
                    if temp == "function" then
                        plan:mirror(functions[v.mirror](k, data.parts[k].name, plan, parentName, data))
                    elseif temp ~= "nil" then
                        plan:mirror(v.mirror[1], v.mirror[2])
                    end
                    temp = type(v.material)
                    if temp == "function" then
                        plan:setMaterial(functions[v.material](k, data.parts[k].name, plan, parentName, data))
                    elseif temp ~= "nil" then
                        plan:setMaterial(v.material)
                    end
                    temp = type(v.color)
                    if temp == "function" then
                        plan:setColor(functions[v.color](k, data.parts[k].name, plan, parentName, data))
                    elseif temp ~= "nil" then
                        plan:setColor(v.color)
                    end
                    v.loaded = true
                    if v.onLoad then
                        functions[v.onLoad](k, data.parts[k].name, plan, parentName, data)
                    end
                    if v.children then
                        print("ModularPlan: Has children")
                        temp = #parents+1
                        parent = plan
                        parents[temp] = parent
                        parentName = k
                        parentNames[temp] = k
                        parentLayers[temp] = layer
                        layer = v.children
                        goto start
                    end
                end
            end
            temp = #parents
            if temp > 0 then
                -- attach parts to parent
                for k, v in pairs(layer) do
                    if v.loaded then
                        print("ModularPlan: attach child", k)
                        plan = data.parts[k].plan
                        parentBlock = type(v.parentBlock)
                        if parentBlock == "function" then
                            parentBlock = functions[v.parentBlock](k, data.parts[k].name, plan, parentName, parent, data)
                        else
                            parentBlock = v.parentBlock
                        end
                        childBlock = type(v.childBlock)
                        if childBlock == "function" then
                            childBlock = functions[v.childBlock](k, data.parts[k].name, plan, parentName, parent, data)
                        else
                            childBlock = v.childBlock
                        end
                        offset = type(v.offset)
                        if offset == "function" then
                            offset = functions[v.offset](k, data.parts[k].name, plan, parentName, parent, data)
                        else
                            offset = v.offset
                        end
                        parent:addPlanDisplaced(parentBlock, plan, childBlock, parent:getBlock(parentBlock).box.position - plan:getBlock(childBlock).box.position + offset)
                    end
                end
                if v.onFinished then
                    functions[v.onFinished](parentName, parent, data)
                end
                -- go up layer
                print("ModularPlan: Go Up level")
                if temp > 1 then
                    parent = parents[temp-1]
                    parents[temp] = nil
                    parentName = parentNames[temp-1]
                    parentNames[temp] = nil
                    layer = parentLayers[temp]
                    parentLayers[temp] = nil
                    goto start
                end
            end
            plan = data.parts.root.plan
            temp = type(config.scale)
            if temp == "function" then
                plan:scale(functions[config.scale](plan, data))
            elseif temp == "number" then
                plan:scale(vec3(config.scale, config.scale, config.scale))
            elseif temp ~= "nil" then
                plan:scale(config.scale)
            end
            temp = type(config.material)
            if temp == "function" then
                plan:setMaterial(functions[config.material](plan, data))
            elseif temp ~= "nil" then
                plan:setMaterial(config.material)
            end
            print("ModularPlan: Plan Finished")
            config.time = appTimeMs() - config.time
            return plan, data
        end
    ]]

    if not config.onPlanFinished then
        return execute(code, config)
    else
        async(config.onPlanFinished, code, config)
    end
end